# Тайм-трекер

### Настройка переменных окружения
Если запускаем через контейнер, то в .env не меняем данные для подключения к базе данных.

```yaml
DB_HOST=localhost #хост базы данных
DB_PORT=5432    #порт базы данных
DB_NAME=admin #имя базы данных
DB_LOGIN=admin #логин для подключения к базы данных
DB_PASS=admin #пароль для подключения к базы данных
SERVER_HOST=localhost #хоят для работы сервера
SERVER_PORT=8080 #порт для работы сервера
API_URL="" # url апи, который обогощает данные о пользоваетле
```
## Запуск контейнера
Собираем образ и поднимаем контейнер:

```golang
docker build -t pg-img .
docker run -d --name pg-con -p 5432:5432 pg-img
```

## Запуск приложения
В корневом каталоге выполняем команду:
```golang
go run main.go
```

## Тестирование
Протестировать можно с помощью swagger:

1. Переходим по адресу http://localhost:8080/swagger/ (если хост и порт другие - поменять соответственно)
2. Информация для записи в БД обогощается с помощью стороннего АПИ (*API_URL* в файле *.env*), если URL не указан - post-запрос */user* будет выдавать ошибку 503, либо 422, если данные не прошли валидацию. Для тестирования записи в БД сдеалн отдельный хендлер */test*.
Выполняем запрос:  
```html
    метод POST

    /test
  
  ```
тело запроса
```JSON
  {
    "passportNumber": "1234 123455"
  }
  ```
Строка *passportNumber* должна передаваться в формате *"4 цифры(номер), пробел, 6 цифр(серия)"*. При удачной записи получаем код-статус 200 и *UserID*. Номер и серия - уникальное поле в БД, поэтому при записи повторяющихся серия+номер получим ошибку и статус код 409. При ошибках - код 500.
3. В предыдущем запросе мы получили *UserID*. Теперь можем узнать информацию о пользователе.
Выполняем Get-запрос
```html
    метод GET

    /user/{userID}
  
  ```

UserID не может быть буквой или символом, иначе получим ошибку в ответе.
При успешном запросе в ответе получаем структуру с данными пользователя:
```JSON
{
  "id": "1",
  "passport_number": "1234 123145",
  "surname": "uhidffl",
  "name": "rwhcq",
  "patronymic": "axqdlpdi",
  "address": "pqcxpstarnnpdbw"
}
```
Данные заполняются рандомно.

4. Колнки surname, name, patronymic и address звполнились рандомно. Теперь можно их отредактировать.
Выполняем запрос 
```html
    метод PUT

    /user/{userID}
  
  ```
В теле нам нужно передать данные, которые мы хотим поменять:
```JSON
{
   "address": "Ростов",
   "name": "Олег",
   "passport_number": "",
   "patronymic": "Владимирович",
   "surname": "Самсонов"
}
```
Поля, которые менять не нужно, оставляем пустыми. ID поменять через данный хендлер нельзя. Если в базе есть запись с серией+номером, на которые мы хотим поменять, то получим код 409.
5. Добавим еще пару пользователей. Теперь выведем 1-ю страницу пользователей, на которой отобразим 3-х пользователя, у которых адресс "Ростов":
Выполняем Post-запрос: 
```html
    метод PUT

    /users/{page}/{limit}
  
  ```
в нашем случае */users/1/3*. В теле запроса указываем, по каким параметрам нам нужно отфильтровать инфомрацию
  ```JSON 
{
   "address": "Ростов",
   "name": "",
   "passport_number": "",
   "patronymic": "",
   "surname": ""
}
```
В ответе получим список пользователей, у которых в поле address запись соответствует "Ростов". У нас будет массив из 1-ой записи, так как только она соответствует фильтру по городу. Если фильтрационные поля оставить пустыми - выведутся все пользователи. 
7. Теперь можно удалить пользователя.
Выполняем DELETE-запрос 
```html
    метод DELETE

    /user/{userID}
  
  ```
При удачном запросе получаем ответ 200. Если попробовать удалить этого же пользователя еще раз - получим статус-код 404.

8. Для добавления задачи определенному пользователю, вводим его UserID.
Выполянем POST-запрос 
```html
    метод POST

    /task/{userID}
  
  ```
в теле запроса нужно передать структуру с названием задачи:
  ```JSON 
{
   "task_name": "Задача №1"
}
```
При успешном запросе получаем ответ 200 и TaskID.
  ```JSON
{
"TaskID": 1
}
```
9. Теперь нужно начать отсчет времени для задачи. Выполянем PUT-запрос
```HTML
метод PUT
/task/start/{taskID}
```
При успешном выполнении получим статус 200, если старт задачи уже дан - код 409.

10. Для добавления конца отсчета времени задачи выполняется PUT-запрос:
```HTML
метод PUT
/task/end/{taskID}
```
При успешном выполнении получим статус 200, если старт задачи не дан - код 428, если поле уже заполнено - код 409.

11. Попробуем получить все задачи определенного пользователя за заданный период. Выполняем GET-запрос: 
```HTML
метод GET
/tasks/{userID}
```
в теле запроса отправляем даты начала и конца периода в формате *"дд.мм.гггг"*.
  ```JSON
{
  "start": "01.01.2020",
  "end": "01.12.2024"
}
```
Если оставить даты пустыми, то автоматичепски проставятся даты старт - 01.01.1900, конец - данное время.